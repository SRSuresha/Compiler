%{
    #include <cstdio>
    #include <cstdlib>

    #include "ast.hpp"
    #include "primitive.hpp"
    #include "symtab.hpp"

    #define YYDEBUG 1

    extern Program_ptr ast;
    int yylex(void);
    void yyerror(const char *);
%}

/* Enables verbose error messages */
%error-verbose

%token MAIN BOOLEAN CHAR INTEGER STRING INTPTR CHARPTR IF ELSE WHILE VAR PROCEDURE RETURN ID NULLX
 %token NUMBER  AND OR STRINGV CHARV TRUE FALSE 
 %left '<' '>' '=' NEQ LE GE EQ 
 %left '+' '-'
 %left '*' '/'
 %right Dummy 

/*


class ProgramImpl;
class Program;
class ProcImpl;
class Proc;
class Procedure_blockImpl;
class Procedure_block;
class Nested_blockImpl;
class Nested_block;
class DeclImpl;
class Decl;
class Assignment;
class Stat;
class StringAssignment;
class Call;
class IfNoElse;
class IfWithElse;
class WhileLoop;
class Return;
class Return_stat;
class TInteger;
class Type;
class TCharacter;
class TBoolean;
class TCharPtr;
class TIntPtr;
class TString;
class AddressOf;
class PExpr;
class Expression;
class And;
class Expr;
class Div;
class Compare;
class Gt;
class Gteq;
class Lt;
class Lteq;
class Minus;
class Noteq;
class Or;
class Plus;
class Times;
class Not;
class Uminus;
class Ident;
class ArrayAccess;
class IntLit;
class CharLit;
class BoolLit;
class Deref;
class Variable;
class Lhs;
class DerefVariable;
class ArrayElement;
class SymName;
class Primitive;
class StringPrimitive;
typedef union
{
std::list<Proc_ptr>* u_proc_list;
Program* u_program;
std::list<Decl_ptr>* u_decl_list;
Proc* u_proc;
std::list<Stat_ptr>* u_stat_list;
Procedure_block* u_procedure_block;
Nested_block* u_nested_block;
std::list<SymName_ptr>* u_symname_list;
Decl* u_decl;
Stat* u_stat;
std::list<PExpr_ptr>* u_pexpr_list;
Return_stat* u_return_stat;
Type* u_type;
PExpr* u_pexpr;
Expr* u_expr;
Lhs* u_lhs;
SymName* u_symname;
Primitive* u_primitive;
StringPrimitive* u_stringprimitive;

// a couple of hardcoded types
char* u_base_charptr;
int u_base_int;
} classunion_stype;
#define YYSTYPE classunion_stype
*/



%%




s       : procedures  
        { 
            $$.u_program = new ProgramImpl($1.u_proc_list);
        }
        ;

procedures  : procedure procedures
            | procedure

procedure : PROCEDURE ID '(' parameter ')' RETURN returnType '{' stmts  '}' 
            {
                $$.u_proc = new ProcImpl($2.u_symname,$4.u_decl_list,$7.u_type,$9.u_stat_list);
            }
        |
        ;


stmts   : stmt stmts
        | stmt

stmt   : lhs '=' exprs ';'    
        {
            $$.u_stat = new Assignment($1.u_lhs,$3.u_expr);
        }   
        | lhs '=' ID '(' arguments ')' ';' 
        {
            $$.u_stat = new Call($1.u_lhs,$3.u_symname,$5.u_expr);
        }
        | ifelseStmt 
        {
            $$.u_stat = $1.u_stat;
        }
        | ifnoelseStmt
        {
            $$.u_stat = $1.u_stat;
        }
        | whileStmt 
        {
            $$.u_stat = $1.u_stat;
        }
        | PROCEDURE ID '(' parameter ')' RETURN type '{' stmts '}' 
        {
            $$.u_proc = new ProcImpl($2.u_symname,$4.u_decl_list,$7.u_type,$9.u_stat_list);
        }
        | VAR ID idPrime ':' declareType ';' {
            std::list<SymName_ptr> *p1 = $3.u_symname_list;
            p1->push_front($2.u_symname);
            $$.u_decl = new DeclImpl(p1,$5.u_type);
        }
        | RETURN exprs ';'
        {
            $$.u_return_stat = new Return($2.u_expr);
        }
        |
        ;


exprs   : NULLX              {$$.u_expr = $1}
        | ID sbarket         {$$.u_expr = new ArrayAccess($1.u_symname,$2.u_expr);}
        | '&' lhs            {$$.u_expr = new AddressOf($2.u_lhs);}
        | STRINGV            {$$.u_expr = $1.u_stringprimitive;}          
        | CHARV              {$$.u_expr = $1.u_base_charptr;}
        | numExprs           {$$.u_expr = $1.u_expr;}           
        | boolExpr           {$$.u_expr = $1.u_expr;}           
        ;

lhs     : ID sbarket        {$$.u_lhs = new ArrayElement($1.u_symname,$2.u_expr);}
        | ID                {$$.u_lhs = new Variable($1.u_symname);}
        | '^' ID            {$$.u_lhs = new DerefVariable($2.u_symname);}
        ;


sbarket : '[' numExprs ']'  {$$.u_expr = $2.u_expr;}
        ;


cop     : EQ | GE | LE | NEQ | '>' | '<'
        ;

aop     : '+' | '-' | '*' |'/'

type    : BOOLEAN           {$$.u_type = new TBoolean();}
        | INTEGER           {$$.u_type = new TInteger();}
        | CHAR              {$$.u_type = new TCharacter();}
        | CHARPTR           {$$.u_type = new TCharPtr();}
        | STRING            {$$.u_type = new TString();}
        | INTPTR            {$$.u_type = new TIntPtr();}
        ;

returnType  : BOOLEAN       {$$.u_type = new TBoolean();}
        | INTEGER           {$$.u_type = new TInteger();}
        | CHAR              {$$.u_type = new TCharacter();}
        | CHARPTR           {$$.u_type = new TCharPtr();}
        | INTPTR            {$$.u_type = new TIntPtr();}
        ;

declareType : BOOLEAN               {$$.u_type = new TBoolean();}
        | INTEGER                   {$$.u_type = new TInteger();}
        | CHAR                      {$$.u_type = new TCharacter();}
        | CHARPTR                   {$$.u_type = new TCharPtr();}
        | INTPTR                    {$$.u_type = new TIntPtr();}
        | STRING '[' NUMBER ']'     {$$.u_type = new TString($3.u_primitive);}
        ;

numExprs: factor termPrime
        ;

term    : ID
        | NUMBER
        | '^' exprs     {$$.expr = new Deref($2.u_expr);}
        | '-' term                      %prec Dummy
        ;

termPrime:  aop factor termPrime            {printf("AOP Factor TermPrime\n");}
        |
        ;

factor  : term                              {printf("Term\n");}
        | '(' numExprs ')'
        | '|' numExprs '|'

arguments : exprs argumentsPrime
        |
        ;

argumentsPrime: ',' exprs argumentsPrime
        |
        ;

boolExpr: term cop term conditions 
        | TRUE conditions
        | FALSE conditions
        | '!' boolExpr
        ; 

conditions: AND boolExpr
        | OR boolExpr
        |
        ;



parameter: ID idPrime ':' returnType parameterPrime
        |
        ;

parameterPrime : ';' ID idPrime ':' returnType parameterPrime
        |
        ;

idPrime : ',' ID idPrime 
        |   
        ;

ifelseStmt  : IF '(' boolExpr ')'  '{' stmts '}' ELSE '{' stmts '}'
            {
                $$.u_stat = new IfWithElse($3.u_expr,$6.u_nested_block,$10.u_nested_block);
            }
        ;

ifnoelseStmt :IF '(' boolExpr ')'  '{' stmts '}' 
        {
            $$.u_stat = new IfNoElse($3.u_expr,$6.u_nested_block);
        }
        ;

whileStmt: WHILE '(' boolExpr ')' '{' stmts '}'     
        {
            $$.u_stat = new WhileLoop($3.u_expr,$6.u_nested_block);
        }
        ;

%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    return;
}
