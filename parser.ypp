%{
    #include <stdio.h>
    #include <stdlib.h>
    #define YYDEBUG 1

    int yylex(void);
    void yyerror(const char *);
%}
 
/* Enables verbose error messages */
%error-verbose

/** WRITE ME:
 *  - Put all your token definitions here
 *  - Put all your type definitions here
 *  - Put all your precedence/associativity rules here
 */

 %token MAIN BOOLEAN CHAR INTEGER STRING INTPTR CHARPTR IF ELSE WHILE VAR PROCEDURE RETURN ID NULLX
 %token NUMBER  AND OR STRINGV CHARV TRUE FALSE
 %left '<' '>' '=' NEQ LE GE EQ 
 %left '+' '-'
 %left '*' '/'
%%

/** WRITE ME:
 *  This is the language from Project 1. You need to put the productions for
 *  the grammar for the language for this project here.
 */
		
S       : PROCEDURE ProcedureStarts MainProcedures Procedures       
        ;

ProcedureStarts: ID '(' Parameter ')' RETURN ReturnType '{' Stmts ReturnStmt '}' PROCEDURE ProcedureStarts
        | 
        ;

Procedures : PROCEDURE ID '(' Parameter ')' RETURN ReturnType '{' Stmts ReturnStmt '}' Procedures
        |
        ;

MainProcedures: MAIN '('  ')'RETURN ReturnType '{' Stmts ReturnStmt '}'
        ;

Stmts   : Lhs '=' Exprs ';' Stmts       {printf("LHS '=' Exprs ';' Stmts\n");}
        | Lhs '=' ID '(' Arguments ')' ';' Stmts
        | IfelseStmt Stmts
        | WhileStmt Stmts
        | PROCEDURE ID '(' Parameter ')' RETURN Type '{' Stmts ReturnStmt '}' Stmts
        | VAR ID IDPrime ':' DeclareType ';' Stmts
        |
        ;


Exprs   : NULLX
        | ID Sbarket                    {printf("ID Sbarket\n");}
        | '&' ID                        {printf("& ID\n");}
        | '&' ID Sbarket                {printf("'&' ID Sbarket\n");}
        | STRINGV                       {printf("STRINGV \n");}
        | CHARV                         {printf("CHARV \n");}
        | NumExprs                      {printf("NumExprs \n");}
        | BoolExpr                      {printf("BoolExpr\n");}
        ;

Lhs     : ID Sbarket
        | ID
        | '&' ID Sbarket
        | '&' ID
        | '^' ID
        ;

Sbarket : '[' NumExprs ']'
        ;


COP     : EQ | GE | LE | NEQ | '>' | '<'
        ;

AOP     : '+' | '-' | '*' |'/'

Type    : BOOLEAN
        | INTEGER
        | CHAR
        | CHARPTR
        | STRING
        | INTPTR
        ;

ReturnType  : BOOLEAN
        | INTEGER
        | CHAR
        | CHARPTR
        | INTPTR
        ;

DeclareType : BOOLEAN
        | INTEGER
        | CHAR
        | CHARPTR
        | INTPTR
        | STRING '[' NUMBER ']'
        ;

NumExprs: Factor TermPrime
        ;

Term    : ID
        | NUMBER
        | '^' ID
        | '^' '('ID '+' NumExprs ')'    {printf("'^' '('ID '+' NumExprs ')'\n");}
        | '^' '('ID '-' NumExprs ')'    {printf("'^' '('ID '-' NumExprs ')' \n");}
        | '^' '(' ID ')'                {printf("'^' '(' ID ')'\n");}
        | '-' Term
        ;

TermPrime:  AOP Factor TermPrime            {printf("AOP Factor TermPrime\n");}
        |
        ;

Factor  : Term                              {printf("Term\n");}
        | '(' NumExprs ')'
        | '|' NumExprs '|'

Arguments : Exprs ArgumentsPrime
        |
        ;

ArgumentsPrime: ',' Exprs ArgumentsPrime
        |
        ;

BoolExpr: Term COP Term Conditions
        | TRUE Conditions
        | FALSE Conditions
        | '!' BoolExpr
        ; 

Conditions: AND BoolExpr
        | OR BoolExpr
        |
        ;

ReturnStmt : RETURN Exprs ';' {printf("return exprs\n");}
        ;

Parameter: ID IDPrime ':' Type ParameterPrime
        |
        ;

ParameterPrime : ';' ID IDPrime ':' Type ParameterPrime
        |
        ;

IDPrime : ',' ID IDPrime 
        |   
        ;

IfelseStmt  : IF '(' BoolExpr ')'  '{' Stmts '}' ElseStmt
        ;

ElseStmt: ELSE '{' Stmts '}'
        |
        ;

WhileStmt: WHILE '(' BoolExpr ')' '{' Stmts '}'
        ;


%%

/** You shall not pass!
 *  You should not  have to do or edit anything past this.
 */

extern int yylineno;

void yyerror(const char *s)
{
    fprintf(stderr, "%s at line %d\n", s, yylineno);
    return;
}
